// DO NOT EDIT MANUALLY - metarpheus-generated
import axios, { AxiosError } from 'axios'
import * as t from 'io-ts'
import * as m from './model-ts'

export interface RouteConfig {
  apiEndpoint: string,
  timeout: number,
  unwrapApiResponse: (resp: any) => any
}

import { failure } from 'io-ts/lib/PathReporter'
export function unsafeValidate<S, A>(value: any, type: t.Type<S, A>): A {
  return t.validate(value, type).fold(errors => {
    throw new Error(failure(errors).join('\n'))
  }, t.identity)
}

const parseError = (err: AxiosError) => {
  try {
    const { errors = [] } = err.response!.data;
    return Promise.reject({ status: err.response!.status, errors });
  } catch (e) {
    return Promise.reject({ status: err && err.response && err.response.status || 0, errors: [] });
  }
};

export default function getRoutes(config: RouteConfig) {
  return {
    /** Create a new search query for available vehicles */
    availableVehicleController_createQuery: function ({ query }: { query: m.AvailableVehicleSearchQuery }): Promise<m.UUID> {
      return axios({
        method: 'post',
        url: `${config.apiEndpoint}/availableVehicles/createQuery`,
        params: {

        },
        data: {
          query
        },
        headers: {
          'Content-Type': 'application/json'
        },
        timeout: config.timeout
      }).then(res => unsafeValidate(config.unwrapApiResponse(res.data), m.UUID), parseError) as any
    },

    /** Returns an existing query for available vehicles */
    availableVehicleController_readQuery: function ({ id }: { id: m.UUID }): Promise<m.AvailableVehicleSearchQuery> {
      return axios({
        method: 'get',
        url: `${config.apiEndpoint}/availableVehicles/readQuery`,
        params: {
          id
        },
        data: {

        },
        headers: {
          'Content-Type': 'application/json',
          'Pragma': 'no-cache',
          'Cache-Control': 'no-cache, no-store'
        },
        timeout: config.timeout
      }).then(res => unsafeValidate(config.unwrapApiResponse(res.data), m.AvailableVehicleSearchQuery), parseError) as any
    },

    /** Returns the resulting available vehicles for the created query */
    availableVehicleController_readResult: function ({ id }: { id: m.UUID }): Promise<m.AvailableVehicleSearchResult> {
      return axios({
        method: 'get',
        url: `${config.apiEndpoint}/availableVehicles/readResult`,
        params: {
          id
        },
        data: {

        },
        headers: {
          'Content-Type': 'application/json',
          'Pragma': 'no-cache',
          'Cache-Control': 'no-cache, no-store'
        },
        timeout: config.timeout
      }).then(res => unsafeValidate(config.unwrapApiResponse(res.data), m.AvailableVehicleSearchResult), parseError) as any
    },

    /** Updates the selected SpecialEquipments for the specified AvailableVehicle */
    availableVehicleController_updateSpecialEquipments: function ({ availableVehicleId, specialEquipments }: { availableVehicleId: m.UUID, specialEquipments: Array<m.SelectedSpecialEquipment> }): Promise<m.UUID> {
      return axios({
        method: 'post',
        url: `${config.apiEndpoint}/availableVehicles/updateSpecialEquipments`,
        params: {

        },
        data: {
          availableVehicleId,
          specialEquipments
        },
        headers: {
          'Content-Type': 'application/json'
        },
        timeout: config.timeout
      }).then(res => unsafeValidate(config.unwrapApiResponse(res.data), m.UUID), parseError) as any
    },

    /** Returns the specified available vehicle */
    availableVehicleController_read: function ({ id }: { id: m.UUID }): Promise<m.AvailableVehicle> {
      return axios({
        method: 'get',
        url: `${config.apiEndpoint}/availableVehicles/read`,
        params: {
          id
        },
        data: {

        },
        headers: {
          'Content-Type': 'application/json',
          'Pragma': 'no-cache',
          'Cache-Control': 'no-cache, no-store'
        },
        timeout: config.timeout
      }).then(res => unsafeValidate(config.unwrapApiResponse(res.data), m.AvailableVehicle), parseError) as any
    },

    /** Search locations */
    locationsController_search: function ({ query }: { query: string }): Promise<m.LocationSearchResult> {
      return axios({
        method: 'get',
        url: `${config.apiEndpoint}/locations/search`,
        params: {
          query
        },
        data: {

        },
        headers: {
          'Content-Type': 'application/json',
          'Pragma': 'no-cache',
          'Cache-Control': 'no-cache, no-store'
        },
        timeout: config.timeout
      }).then(res => unsafeValidate(config.unwrapApiResponse(res.data), m.LocationSearchResult), parseError) as any
    },

    /** Get available SpecialEquipment for a given pickUp Location and rental duration */
    locationsController_searchSpecialEquipments: function ({ location, duration, param1, param2 }: { location: string, duration: number, param1: number, param2: string }): Promise<Array<m.AvailableSpecialEquipment>> {
      return axios({
        method: 'get',
        url: `${config.apiEndpoint}/locations/searchSpecialEquipments/${param1}/foo/${param2}`,
        params: {
          location,
          duration
        },
        data: {

        },
        headers: {
          'Content-Type': 'application/json',
          'Pragma': 'no-cache',
          'Cache-Control': 'no-cache, no-store'
        },
        timeout: config.timeout
      }).then(res => unsafeValidate(config.unwrapApiResponse(res.data), t.array(m.AvailableSpecialEquipment)), parseError) as any
    },

    /** log a user in */
    userController_login: function ({ data }: { data: m.API_UserLoginCredentials }): Promise<m.API_UserAuthCredentials> {
      return axios({
        method: 'post',
        url: `${config.apiEndpoint}/users/login`,
        params: {

        },
        data: data,
        headers: {
          'Content-Type': 'application/json'
        },
        timeout: config.timeout
      }).then(res => unsafeValidate(config.unwrapApiResponse(res.data), m.API_UserAuthCredentials), parseError) as any
    }
  }
}
