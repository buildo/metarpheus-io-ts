// DO NOT EDIT MANUALLY - metarpheus-generated
import axios, { AxiosError } from 'axios'
import * as t from 'io-ts'
import * as m from './model-ts'

export interface RouteConfig {
  apiEndpoint: string,
  timeout: number,
  unwrapApiResponse: (resp: any) => any
}

import { PathReporter } from 'io-ts/lib/PathReporter'
function valueOrThrow<T extends t.Type<any, any>>(iotsType: T, value: T['_I']): t.TypeOf<T> {
  const validatedValue = iotsType.decode(value);

  if (validatedValue.isLeft()) {
    throw new Error(PathReporter.report(validatedValue).join('\n'));
  }

  return validatedValue.value;
}

const parseError = (err: AxiosError) => {
  try {
    const { errors = [] } = err.response!.data;
    return Promise.reject({ status: err.response!.status, errors });
  } catch (e) {
    return Promise.reject({ status: err && err.response && err.response.status || 0, errors: [] });
  }
};

export default function getRoutes(config: RouteConfig) {
  return {
    /** Create a new search query for available vehicles */
    availableVehicleController_createQuery: function ({ query }: { query: m.AvailableVehicleSearchQuery }): Promise<string> {
      return axios({
        method: 'post',
        url: `${config.apiEndpoint}/availableVehicles/createQuery`,
        params: {

        },
        data: {
          query
        },
        headers: {
          'Content-Type': 'application/json'
        },
        timeout: config.timeout
      }).then(res => valueOrThrow(t.string, config.unwrapApiResponse(res.data)), parseError) as any
    },

    /** Returns an existing query for available vehicles */
    availableVehicleController_readQuery: function ({ id }: { id: string }): Promise<m.AvailableVehicleSearchQuery> {
      return axios({
        method: 'get',
        url: `${config.apiEndpoint}/availableVehicles/readQuery`,
        params: {
          id
        },
        data: {

        },
        headers: {
          'Content-Type': 'application/json',
          'Pragma': 'no-cache',
          'Cache-Control': 'no-cache, no-store'
        },
        timeout: config.timeout
      }).then(res => valueOrThrow(m.AvailableVehicleSearchQuery, config.unwrapApiResponse(res.data)), parseError) as any
    },

    /** Returns the resulting available vehicles for the created query */
    availableVehicleController_readResult: function ({ id }: { id: string }): Promise<m.AvailableVehicleSearchResult> {
      return axios({
        method: 'get',
        url: `${config.apiEndpoint}/availableVehicles/readResult`,
        params: {
          id
        },
        data: {

        },
        headers: {
          'Content-Type': 'application/json',
          'Pragma': 'no-cache',
          'Cache-Control': 'no-cache, no-store'
        },
        timeout: config.timeout
      }).then(res => valueOrThrow(m.AvailableVehicleSearchResult, config.unwrapApiResponse(res.data)), parseError) as any
    },

    /** Updates the selected SpecialEquipments for the specified AvailableVehicle */
    availableVehicleController_updateSpecialEquipments: function ({ token, availableVehicleId, specialEquipments }: { token: string, availableVehicleId: string, specialEquipments: Array<m.SelectedSpecialEquipment> }): Promise<string> {
      return axios({
        method: 'post',
        url: `${config.apiEndpoint}/availableVehicles/updateSpecialEquipments`,
        params: {

        },
        data: {
          availableVehicleId,
          specialEquipments
        },
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Token token="${token}"`
        },
        timeout: config.timeout
      }).then(res => valueOrThrow(t.string, config.unwrapApiResponse(res.data)), parseError) as any
    },

    /** Returns the specified available vehicle */
    availableVehicleController_read: function ({ id }: { id: string }): Promise<m.AvailableVehicle> {
      return axios({
        method: 'get',
        url: `${config.apiEndpoint}/availableVehicles/read`,
        params: {
          id
        },
        data: {

        },
        headers: {
          'Content-Type': 'application/json',
          'Pragma': 'no-cache',
          'Cache-Control': 'no-cache, no-store'
        },
        timeout: config.timeout
      }).then(res => valueOrThrow(m.AvailableVehicle, config.unwrapApiResponse(res.data)), parseError) as any
    },

    /** Search locations */
    locationsController_search: function ({ query }: { query: string }): Promise<m.LocationSearchResult> {
      return axios({
        method: 'get',
        url: `${config.apiEndpoint}/locations/search`,
        params: {
          query
        },
        data: {

        },
        headers: {
          'Content-Type': 'application/json',
          'Pragma': 'no-cache',
          'Cache-Control': 'no-cache, no-store'
        },
        timeout: config.timeout
      }).then(res => valueOrThrow(m.LocationSearchResult, config.unwrapApiResponse(res.data)), parseError) as any
    },

    /** Get available SpecialEquipment for a given pickUp Location and rental duration */
    locationsController_searchSpecialEquipments: function ({ location, duration, param1, param2 }: { location: string, duration: number, param1: number, param2: string }): Promise<Array<m.AvailableSpecialEquipment>> {
      return axios({
        method: 'get',
        url: `${config.apiEndpoint}/locations/searchSpecialEquipments/${param1}/foo/${param2}`,
        params: {
          location,
          duration
        },
        data: {

        },
        headers: {
          'Content-Type': 'application/json',
          'Pragma': 'no-cache',
          'Cache-Control': 'no-cache, no-store'
        },
        timeout: config.timeout
      }).then(res => valueOrThrow(t.array(m.AvailableSpecialEquipment), config.unwrapApiResponse(res.data)), parseError) as any
    },

    /** log a user in */
    userController_login: function ({ data }: { data: m.API_UserLoginCredentials }): Promise<m.API_UserAuthCredentials> {
      return axios({
        method: 'post',
        url: `${config.apiEndpoint}/users/login`,
        params: {

        },
        data: data,
        headers: {
          'Content-Type': 'application/json'
        },
        timeout: config.timeout
      }).then(res => valueOrThrow(m.API_UserAuthCredentials, config.unwrapApiResponse(res.data)), parseError) as any
    }
  }
}
