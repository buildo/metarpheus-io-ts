// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`getModels should allow legacy newtype encoding 1`] = `
"// DO NOT EDIT MANUALLY - metarpheus-generated
import * as t from 'io-ts'
// @ts-ignore
import { optionFromNullable } from 'io-ts-types/lib/optionFromNullable'
// @ts-ignore
import { Option } from 'fp-ts/lib/Option'


interface Newtype<URI, A> {
  _URI: URI
  _A: A
}
interface Iso<S, A> {
  unwrap: (s: S) => A
  wrap: (a: A) => S
}
const unsafeCoerce = <A, B>(a: A): B => a as any
type Carrier<N extends Newtype<any, any>> = N['_A']
type AnyNewtype = Newtype<any, any>
const fromNewtype = <N extends AnyNewtype>() => <O>(type: t.Type<Carrier<N>, O>): t.Type<N, O> =>
  type as any
const iso = <S extends AnyNewtype>(): Iso<S, Carrier<S>> =>
  ({ wrap: unsafeCoerce, unwrap: unsafeCoerce })

export const VoidFromUnit = new t.Type<void, {}>(
  'VoidFromUnit',
  (_m): _m is void => true,
  () => t.success(undefined),
  () => ({})
)
export interface ExternalId<A> extends Newtype<{ readonly ExternalId: 'ExternalId', readonly ExternalId_A: A }, string> {}

export function ExternalId<A>() { return fromNewtype<ExternalId<A>>()(t.string) }
export function externalIdIso<A>() { return iso<ExternalId<A>>() }
"
`;

exports[`getModels should handle any 1`] = `
"// DO NOT EDIT MANUALLY - metarpheus-generated
import * as t from 'io-ts'
// @ts-ignore
import { optionFromNullable } from 'io-ts-types/lib/optionFromNullable'
// @ts-ignore
import { Option } from 'fp-ts/lib/Option'

export const VoidFromUnit = new t.Type<void, {}>(
  'VoidFromUnit',
  (_m): _m is void => true,
  () => t.success(undefined),
  () => ({})
)
export interface NotificationPayload {
  userLanguage: Option<string>,
  notificationKind: NotificationKind,
  params: Record<string, unknown>,
  workcellSerialNumber: string,
  workcellType: InstrumentType
}

export const NotificationPayload = t.type({
  userLanguage: optionFromNullable(t.string),
  notificationKind: NotificationKind,
  params: t.record(t.string, t.unknown),
  workcellSerialNumber: t.string,
  workcellType: InstrumentType
}, 'NotificationPayload')
"
`;

exports[`getModels should handle tagged union types 1`] = `
"// DO NOT EDIT MANUALLY - metarpheus-generated
import * as t from 'io-ts'
// @ts-ignore
import { optionFromNullable } from 'io-ts-types/lib/optionFromNullable'
// @ts-ignore
import { Option } from 'fp-ts/lib/Option'

export const VoidFromUnit = new t.Type<void, {}>(
  'VoidFromUnit',
  (_m): _m is void => true,
  () => t.success(undefined),
  () => ({})
)
export interface SuggestedNames {
  names: Array<string>
}

export const SuggestedNames = t.type({
  names: t.array(t.string)
}, 'SuggestedNames')

export type CreateCampingError =
  | {
  /** suggestions for names that are not in use */
  names: SuggestedNames,
  _type: 'DuplicateName'
}
  | {
  min: number,
  max: number,
  _type: 'SizeOutOfBounds'
}
  | {
  _type: 'OtherError'
}

export const CreateCampingError = t.union([
  t.type({
    /** suggestions for names that are not in use */
    names: SuggestedNames,
    _type: t.literal('DuplicateName')
  }, 'DuplicateName'),
  t.type({
    min: t.Integer,
    max: t.Integer,
    _type: t.literal('SizeOutOfBounds')
  }, 'SizeOutOfBounds'),
  t.type({
    _type: t.literal('OtherError')
  }, 'OtherError')
], 'CreateCampingError')

export interface SingleCaseTaggedUnion {
  x: number,
  y: string,
  _type: 'SingleCase'
}

export const SingleCaseTaggedUnion = t.type({
  x: t.Integer,
  y: t.string,
  _type: t.literal('SingleCase')
}, 'SingleCase')

export type Surface =
  | {
  _type: 'Sand'
}
  | {
  _type: 'Earth'
}

export const Surface = t.union([
  t.type({
    _type: t.literal('Sand')
  }, 'Sand'),
  t.type({
    _type: t.literal('Earth')
  }, 'Earth')
], 'Surface')
"
`;

exports[`getModels should return the models (source1) 1`] = `
"// DO NOT EDIT MANUALLY - metarpheus-generated
import * as t from 'io-ts'
// @ts-ignore
import { optionFromNullable } from 'io-ts-types/lib/optionFromNullable'
// @ts-ignore
import { Option } from 'fp-ts/lib/Option'


interface Newtype<URI, A> {
  _URI: URI
  _A: A
}
interface Iso<S, A> {
  unwrap: (s: S) => A
  wrap: (a: A) => S
}
const unsafeCoerce = <A, B>(a: A): B => a as any
type Carrier<N extends Newtype<any, any>> = N['_A']
type AnyNewtype = Newtype<any, any>
const fromNewtype = <N extends AnyNewtype>() => <O>(type: t.Type<Carrier<N>, O>): t.Type<N, O> =>
  type as any
const iso = <S extends AnyNewtype>(): Iso<S, Carrier<S>> =>
  ({ wrap: unsafeCoerce, unwrap: unsafeCoerce })

export const VoidFromUnit = new t.Type<void, {}>(
  'VoidFromUnit',
  (_m): _m is void => true,
  () => t.success(undefined),
  () => ({})
)
export type CampingLocation =
  | 'Seaside'
  | 'Mountains'

export const CampingLocation = t.keyof({
  Seaside: null,
  Mountains: null
}, 'CampingLocation')

export interface Camping {
  /** camping name */
  name: string,
  /** number of tents */
  size: number,
  /** camping location */
  location: CampingLocation
}

export const Camping = t.type({
  /** camping name */
  name: t.string,
  /** number of tents */
  size: t.Integer,
  /** camping location */
  location: CampingLocation
}, 'Camping')

export interface HealthId extends Newtype<{ readonly HealthId: unique symbol }, string> {}

export const HealthId = fromNewtype<HealthId>()(t.string);
export const healthIdIso = iso<HealthId>();

export interface Health {
  /** Name of the service. */
  id: HealthId,
  /** Version of the service. */
  version: string,
  /** Current UTC date and time of the request, in ISO 8601 format. */
  currentAsOfUtc: Date
}

export const Health = t.type({
  /** Name of the service. */
  id: HealthId,
  /** Version of the service. */
  version: t.string,
  /** Current UTC date and time of the request, in ISO 8601 format. */
  currentAsOfUtc: Date
}, 'Health')

export type ICQAlertCategory =
  | 'Critical'
  | 'Alert'
  | 'Notification'

export const ICQAlertCategory = t.keyof({
  Critical: null,
  Alert: null,
  Notification: null
}, 'ICQAlertCategory')

export interface ICQAlert {
  _moduleId: number,
  moduleName: string,
  _workcellSerialNumber: string,
  workcellName: string,
  AIMCode: number,
  AIMSubCode: Option<number>,
  alertDateTime: Date,
  category: ICQAlertCategory,
  description: string
}

export const ICQAlert = t.type({
  _moduleId: t.Integer,
  moduleName: t.string,
  _workcellSerialNumber: t.string,
  workcellName: t.string,
  AIMCode: t.Integer,
  AIMSubCode: optionFromNullable(t.Integer),
  alertDateTime: Date,
  category: ICQAlertCategory,
  description: t.string
}, 'ICQAlert')

export interface ICQAssayReference {
  _number: number,
  _version: number
}

export const ICQAssayReference = t.type({
  _number: t.Integer,
  _version: t.Integer
}, 'ICQAssayReference')

export type ICQCalibrationMethod =
  | 'Qual1Point'
  | 'Qual2Point'
  | 'CalValueReference'
  | 'ICT'
  | 'Exponential'
  | 'Linear'
  | 'Spline'
  | 'ABS'
  | 'Factor'
  | 'UseFactor'
  | 'UseFactorBlank'
  | 'PLC4Y'
  | 'PLC4X'
  | 'PLC4XTransform'
  | 'PLC5Y'
  | 'PLC5X'
  | 'PLC5XTransform'
  | 'PointToPoint'
  | 'IAReference'
  | 'Logit-4'
  | 'Logit-5'

export const ICQCalibrationMethod = t.keyof({
  Qual1Point: null,
  Qual2Point: null,
  CalValueReference: null,
  ICT: null,
  Exponential: null,
  Linear: null,
  Spline: null,
  ABS: null,
  Factor: null,
  UseFactor: null,
  UseFactorBlank: null,
  PLC4Y: null,
  PLC4X: null,
  PLC4XTransform: null,
  PLC5Y: null,
  PLC5X: null,
  PLC5XTransform: null,
  PointToPoint: null,
  IAReference: null,
  'Logit-4': null,
  'Logit-5': null
}, 'ICQCalibrationMethod')

export type ICQCalibrationType =
  | 'Full'
  | 'Adjust'

export const ICQCalibrationType = t.keyof({
  Full: null,
  Adjust: null
}, 'ICQCalibrationType')

export type ICQCalibrationStatus =
  | 'NoCal'
  | 'Ok'
  | 'Failed'
  | 'Expired'
  | 'Overridden'
  | 'OverriddenLot'
  | 'PendingQC'
  | 'InProcess'

export const ICQCalibrationStatus = t.keyof({
  NoCal: null,
  Ok: null,
  Failed: null,
  Expired: null,
  Overridden: null,
  OverriddenLot: null,
  PendingQC: null,
  InProcess: null
}, 'ICQCalibrationStatus')

export interface ICQCalibration {
  _moduleId: number,
  moduleName: string,
  _workcellSerialNumber: string,
  workcellName: string,
  assayReference: ICQAssayReference,
  assayName: string,
  reagentLotNumber: string,
  calibratorLotNumber: string,
  method: ICQCalibrationMethod,
  type: ICQCalibrationType,
  calibrationDateTime: Option<Date>,
  expirationDateTime: Option<Date>,
  status: ICQCalibrationStatus,
  user: Option<string>
}

export const ICQCalibration = t.type({
  _moduleId: t.Integer,
  moduleName: t.string,
  _workcellSerialNumber: t.string,
  workcellName: t.string,
  assayReference: ICQAssayReference,
  assayName: t.string,
  reagentLotNumber: t.string,
  calibratorLotNumber: t.string,
  method: ICQCalibrationMethod,
  type: ICQCalibrationType,
  calibrationDateTime: optionFromNullable(Date),
  expirationDateTime: optionFromNullable(Date),
  status: ICQCalibrationStatus,
  user: optionFromNullable(t.string)
}, 'ICQCalibration')

export type ICQConnectionStatus =
  | 'Connected'
  | 'NotConnected'
  | 'NotConfigured'

export const ICQConnectionStatus = t.keyof({
  Connected: null,
  NotConnected: null,
  NotConfigured: null
}, 'ICQConnectionStatus')

export type ICQModuleStatus =
  | 'Offline'
  | 'Stopped'
  | 'Initializing'
  | 'Warming'
  | 'Idle'
  | 'Running'
  | 'Processing'
  | 'Pausing'
  | 'Maintenance'

export const ICQModuleStatus = t.keyof({
  Offline: null,
  Stopped: null,
  Initializing: null,
  Warming: null,
  Idle: null,
  Running: null,
  Processing: null,
  Pausing: null,
  Maintenance: null
}, 'ICQModuleStatus')

export type ICQModuleType =
  | 'IA'
  | 'CC'

export const ICQModuleType = t.keyof({
  IA: null,
  CC: null
}, 'ICQModuleType')

export type ICQReagentStatus =
  | 'Ok'
  | 'Mixing'
  | 'Overridden'
  | 'Disabled'
  | 'LowAlert'
  | 'Expired'
  | 'ExpiredError'
  | 'Empty'
  | 'NoAssay'
  | 'PickError'
  | 'PlaceError'
  | 'LoadError'
  | 'Incomplete'
  | 'BCFail'
  | 'Undefined'

export const ICQReagentStatus = t.keyof({
  Ok: null,
  Mixing: null,
  Overridden: null,
  Disabled: null,
  LowAlert: null,
  Expired: null,
  ExpiredError: null,
  Empty: null,
  NoAssay: null,
  PickError: null,
  PlaceError: null,
  LoadError: null,
  Incomplete: null,
  BCFail: null,
  Undefined: null
}, 'ICQReagentStatus')

export type ICQReagentCartridgeStatus =
  | 'Ok'
  | 'UnloadError'
  | 'LoadError'
  | 'ScheduledUnload'
  | 'ScheduledLoad'
  | 'PartiallyUnloaded'
  | 'Scanning'
  | 'Unloading'
  | 'Loading'

export const ICQReagentCartridgeStatus = t.keyof({
  Ok: null,
  UnloadError: null,
  LoadError: null,
  ScheduledUnload: null,
  ScheduledLoad: null,
  PartiallyUnloaded: null,
  Scanning: null,
  Unloading: null,
  Loading: null
}, 'ICQReagentCartridgeStatus')

export interface ICQOnBoardSolution {
  _moduleId: number,
  moduleName: string,
  _workcellSerialNumber: string,
  workcellName: string,
  _lotNumber: string,
  _serialNumber: string,
  configurationId: string,
  configurationVersion: number,
  expirationDate: Date,
  carouselPosition: Option<number>,
  RSMPosition: Option<number>,
  percentOfRemainingVolume: number,
  remainingHoursOfOnBoardStability: Option<number>,
  status: ICQReagentStatus,
  cartridgeStatus: ICQReagentCartridgeStatus
}

export const ICQOnBoardSolution = t.type({
  _moduleId: t.Integer,
  moduleName: t.string,
  _workcellSerialNumber: t.string,
  workcellName: t.string,
  _lotNumber: t.string,
  _serialNumber: t.string,
  configurationId: t.string,
  configurationVersion: t.Integer,
  expirationDate: Date,
  carouselPosition: optionFromNullable(t.Integer),
  RSMPosition: optionFromNullable(t.Integer),
  percentOfRemainingVolume: t.Integer,
  remainingHoursOfOnBoardStability: optionFromNullable(t.Integer),
  status: ICQReagentStatus,
  cartridgeStatus: ICQReagentCartridgeStatus
}, 'ICQOnBoardSolution')

export type ICQOverallStatus =
  | 'Ok'
  | 'Warning'
  | 'Error'

export const ICQOverallStatus = t.keyof({
  Ok: null,
  Warning: null,
  Error: null
}, 'ICQOverallStatus')

export type ICQPrinterStatus =
  | 'NoError'
  | 'Warning'
  | 'Error'
  | 'NotConfigured'

export const ICQPrinterStatus = t.keyof({
  NoError: null,
  Warning: null,
  Error: null,
  NotConfigured: null
}, 'ICQPrinterStatus')

export interface ICQProcessingModule {
  _id: number,
  serialNumber: string,
  type: ICQModuleType,
  name: string,
  overallStatus: ICQOverallStatus,
  status: ICQModuleStatus,
  numberOfTestsInProgress: number,
  reagentOverallStatus: ICQOverallStatus,
  supplyOverallStatus: ICQOverallStatus,
  calibrationOverallStatus: ICQOverallStatus,
  QCAnalysisOverallStatus: ICQOverallStatus,
  maintenanceOverallStatus: ICQOverallStatus
}

export const ICQProcessingModule = t.type({
  _id: t.Integer,
  serialNumber: t.string,
  type: ICQModuleType,
  name: t.string,
  overallStatus: ICQOverallStatus,
  status: ICQModuleStatus,
  numberOfTestsInProgress: t.Integer,
  reagentOverallStatus: ICQOverallStatus,
  supplyOverallStatus: ICQOverallStatus,
  calibrationOverallStatus: ICQOverallStatus,
  QCAnalysisOverallStatus: ICQOverallStatus,
  maintenanceOverallStatus: ICQOverallStatus
}, 'ICQProcessingModule')

export type ICQQCAnalysisStatus =
  | 'Success'
  | 'QCOutOfRange'
  | 'WestgardWarning'
  | 'WestgardFailure'

export const ICQQCAnalysisStatus = t.keyof({
  Success: null,
  QCOutOfRange: null,
  WestgardWarning: null,
  WestgardFailure: null
}, 'ICQQCAnalysisStatus')

export interface ICQQCAnalysis {
  _moduleId: number,
  moduleName: string,
  _workcellSerialNumber: string,
  workcellName: string,
  assayReference: ICQAssayReference,
  assayName: string,
  controlSetName: string,
  controlLevelName: string,
  controlLotNumber: string,
  assayQCStatus: ICQQCAnalysisStatus
}

export const ICQQCAnalysis = t.type({
  _moduleId: t.Integer,
  moduleName: t.string,
  _workcellSerialNumber: t.string,
  workcellName: t.string,
  assayReference: ICQAssayReference,
  assayName: t.string,
  controlSetName: t.string,
  controlLevelName: t.string,
  controlLotNumber: t.string,
  assayQCStatus: ICQQCAnalysisStatus
}, 'ICQQCAnalysis')

export type ICQQCMaterialStatus =
  | 'Ok'
  | 'LowAlert'
  | 'Empty'
  | 'Expired'
  | 'Overridden'

export const ICQQCMaterialStatus = t.keyof({
  Ok: null,
  LowAlert: null,
  Empty: null,
  Expired: null,
  Overridden: null
}, 'ICQQCMaterialStatus')

export interface ICQQCMaterial {
  _moduleId: number,
  moduleName: string,
  _workcellSerialNumber: string,
  workcellName: string,
  assayReferences: Array<ICQAssayReference>,
  assayNames: Array<string>,
  _setName: string,
  _levelName: string,
  _lotNumber: string,
  _serialNumber: string,
  carouselPosition: Option<number>,
  RSMPosition: Option<number>,
  rackId: string,
  rackPosition: number,
  percentVolumeRemaining: number,
  materialExpirationDate: Date,
  remainingHoursOfOnBoardStability: number,
  remainingMinutesOfInUseStability: Option<number>,
  status: ICQQCMaterialStatus
}

export const ICQQCMaterial = t.type({
  _moduleId: t.Integer,
  moduleName: t.string,
  _workcellSerialNumber: t.string,
  workcellName: t.string,
  assayReferences: t.array(ICQAssayReference),
  assayNames: t.array(t.string),
  _setName: t.string,
  _levelName: t.string,
  _lotNumber: t.string,
  _serialNumber: t.string,
  carouselPosition: optionFromNullable(t.Integer),
  RSMPosition: optionFromNullable(t.Integer),
  rackId: t.string,
  rackPosition: t.Integer,
  percentVolumeRemaining: t.Integer,
  materialExpirationDate: Date,
  remainingHoursOfOnBoardStability: t.Integer,
  remainingMinutesOfInUseStability: optionFromNullable(t.Integer),
  status: ICQQCMaterialStatus
}, 'ICQQCMaterial')

export type ICQRSMStatus =
  | 'Offline'
  | 'Stopped'
  | 'Initializing'
  | 'Idle'
  | 'Running'
  | 'Pausing'
  | 'Maintenance'

export const ICQRSMStatus = t.keyof({
  Offline: null,
  Stopped: null,
  Initializing: null,
  Idle: null,
  Running: null,
  Pausing: null,
  Maintenance: null
}, 'ICQRSMStatus')

export interface ICQRSM {
  serialNumber: string,
  name: string,
  overallStatus: ICQOverallStatus,
  status: ICQRSMStatus
}

export const ICQRSM = t.type({
  serialNumber: t.string,
  name: t.string,
  overallStatus: ICQOverallStatus,
  status: ICQRSMStatus
}, 'ICQRSM')

export interface ICQWorkcell {
  _serialNumber: string,
  name: string,
  numberOfSamples: number,
  numberOfResultsPending: number,
  numberOfExceptions: number,
  LISConnectionStatus: ICQConnectionStatus,
  LASConnectionStatus: ICQConnectionStatus,
  AbbottLinkConnectionStatus: ICQConnectionStatus,
  PrinterConnectionStatus: ICQPrinterStatus,
  currentUser: string,
  processingModules: Array<ICQProcessingModule>,
  RSM: ICQRSM
}

export const ICQWorkcell = t.type({
  _serialNumber: t.string,
  name: t.string,
  numberOfSamples: t.Integer,
  numberOfResultsPending: t.Integer,
  numberOfExceptions: t.Integer,
  LISConnectionStatus: ICQConnectionStatus,
  LASConnectionStatus: ICQConnectionStatus,
  AbbottLinkConnectionStatus: ICQConnectionStatus,
  PrinterConnectionStatus: ICQPrinterStatus,
  currentUser: t.string,
  processingModules: t.array(ICQProcessingModule),
  RSM: ICQRSM
}, 'ICQWorkcell')
"
`;

exports[`getModels should return the models in the right (source2) 1`] = `
"// DO NOT EDIT MANUALLY - metarpheus-generated
import * as t from 'io-ts'
// @ts-ignore
import { optionFromNullable } from 'io-ts-types/lib/optionFromNullable'
// @ts-ignore
import { Option } from 'fp-ts/lib/Option'

export const VoidFromUnit = new t.Type<void, {}>(
  'VoidFromUnit',
  (_m): _m is void => true,
  () => t.success(undefined),
  () => ({})
)
export interface Tag {
  id: UUID,
  label: string
}

export const Tag = t.type({
  id: UUID,
  label: t.string
}, 'Tag')

export interface AgencySearchResult {
  agencies: Array<Tag>,
  networks: Array<Tag>
}

export const AgencySearchResult = t.type({
  agencies: t.array(Tag),
  networks: t.array(Tag)
}, 'AgencySearchResult')

export type CancellationPolicy =
  | 'Free'

export const CancellationPolicy = t.keyof({
  Free: null
}, 'CancellationPolicy')

export type Vendor =
  | 'Hertz'
  | 'Dollar'
  | 'FireFly'
  | 'Thrifty'

export const Vendor = t.keyof({
  Hertz: null,
  Dollar: null,
  FireFly: null,
  Thrifty: null
}, 'Vendor')

export type PaymentMode =
  | 'Cash'
  | 'Prepaid'

export const PaymentMode = t.keyof({
  Cash: null,
  Prepaid: null
}, 'PaymentMode')

export interface FareRule {
  pickUpValidFrom: Option<LocalDate>,
  pickUpValidUntil: Option<LocalDate>,
  reservationValidFrom: Option<LocalDate>,
  reservationValidUntil: Option<LocalDate>,
  nations: Array<Tag>,
  agencies: Array<Tag>
}

export const FareRule = t.type({
  pickUpValidFrom: optionFromNullable(LocalDate),
  pickUpValidUntil: optionFromNullable(LocalDate),
  reservationValidFrom: optionFromNullable(LocalDate),
  reservationValidUntil: optionFromNullable(LocalDate),
  nations: t.array(Tag),
  agencies: t.array(Tag)
}, 'FareRule')

export interface Fare {
  id: UUID,
  name: string,
  vendor: Vendor,
  paymentMode: PaymentMode,
  rateCode: string,
  cdp: Option<string>,
  tourOperatorCode: Option<string>,
  additionalInclusions: Option<string>,
  cancellationPolicy: CancellationPolicy,
  description: string,
  disabled: boolean,
  rules: Array<FareRule>
}

export const Fare = t.type({
  id: UUID,
  name: t.string,
  vendor: Vendor,
  paymentMode: PaymentMode,
  rateCode: t.string,
  cdp: optionFromNullable(t.string),
  tourOperatorCode: optionFromNullable(t.string),
  additionalInclusions: optionFromNullable(t.string),
  cancellationPolicy: CancellationPolicy,
  description: t.string,
  disabled: t.boolean,
  rules: t.array(FareRule)
}, 'Fare')

export type ReservationProfile =
  | 'Leisure'
  | 'Business'
  | 'TourOperator'

export const ReservationProfile = t.keyof({
  Leisure: null,
  Business: null,
  TourOperator: null
}, 'ReservationProfile')

export interface FareSummary {
  id: UUID,
  reservationProfile: ReservationProfile,
  name: string,
  vendor: Vendor,
  paymentMode: PaymentMode,
  disabled: boolean
}

export const FareSummary = t.type({
  id: UUID,
  reservationProfile: ReservationProfile,
  name: t.string,
  vendor: Vendor,
  paymentMode: PaymentMode,
  disabled: t.boolean
}, 'FareSummary')

export type FareSummarySorting =
  | 'Name'
  | 'Vendor'
  | 'PaymentMode'
  | 'Disabled'

export const FareSummarySorting = t.keyof({
  Name: null,
  Vendor: null,
  PaymentMode: null,
  Disabled: null
}, 'FareSummarySorting')

export interface NationSearchResult {
  regions: Array<Tag>,
  countries: Array<Tag>,
  states: Array<Tag>
}

export const NationSearchResult = t.type({
  regions: t.array(Tag),
  countries: t.array(Tag),
  states: t.array(Tag)
}, 'NationSearchResult')

export interface NewFare {
  name: string,
  vendor: Vendor,
  paymentMode: PaymentMode,
  rateCode: string,
  cdp: Option<string>,
  additionalInclusions: Option<string>,
  tourOperatorCode: Option<string>,
  cancellationPolicy: CancellationPolicy,
  description: string,
  disabled: boolean,
  rules: Array<Option<FareRule>>
}

export const NewFare = t.type({
  name: t.string,
  vendor: Vendor,
  paymentMode: PaymentMode,
  rateCode: t.string,
  cdp: optionFromNullable(t.string),
  additionalInclusions: optionFromNullable(t.string),
  tourOperatorCode: optionFromNullable(t.string),
  cancellationPolicy: CancellationPolicy,
  description: t.string,
  disabled: t.boolean,
  rules: t.array(optionFromNullable(FareRule))
}, 'NewFare')

export type SortOrder =
  | 'Ascending'
  | 'Descending'

export const SortOrder = t.keyof({
  Ascending: null,
  Descending: null
}, 'SortOrder')
"
`;

exports[`getModels should return the models in the right (source3) 1`] = `
"// DO NOT EDIT MANUALLY - metarpheus-generated
import * as t from 'io-ts'
// @ts-ignore
import { optionFromNullable } from 'io-ts-types/lib/optionFromNullable'
// @ts-ignore
import { Option } from 'fp-ts/lib/Option'

export const VoidFromUnit = new t.Type<void, {}>(
  'VoidFromUnit',
  (_m): _m is void => true,
  () => t.success(undefined),
  () => ({})
)
export type Vendor =
  | 'Hertz'
  | 'Dollar'
  | 'FireFly'
  | 'Thrifty'

export const Vendor = t.keyof({
  Hertz: null,
  Dollar: null,
  FireFly: null,
  Thrifty: null
}, 'Vendor')

export type PaymentMode =
  | 'Cash'
  | 'Prepaid'

export const PaymentMode = t.keyof({
  Cash: null,
  Prepaid: null
}, 'PaymentMode')

export type CancellationPolicy =
  | 'Free'

export const CancellationPolicy = t.keyof({
  Free: null
}, 'CancellationPolicy')

export interface AvailableFare {
  id: UUID,
  name: string,
  vendor: Vendor,
  paymentMode: PaymentMode,
  additionalInclusions: Option<string>,
  explicitExclusions: Option<string>,
  cancellationPolicy: CancellationPolicy,
  description: Option<string>
}

export const AvailableFare = t.type({
  id: UUID,
  name: t.string,
  vendor: Vendor,
  paymentMode: PaymentMode,
  additionalInclusions: optionFromNullable(t.string),
  explicitExclusions: optionFromNullable(t.string),
  cancellationPolicy: CancellationPolicy,
  description: optionFromNullable(t.string)
}, 'AvailableFare')

export interface RentalRateTotal {
  base: Money,
  estimatedIncludingTaxes: Money
}

export const RentalRateTotal = t.type({
  base: Money,
  estimatedIncludingTaxes: Money
}, 'RentalRateTotal')

export type RentalRateDistanceUnit =
  | 'Km'
  | 'Mile'
  | 'Block'

export const RentalRateDistanceUnit = t.keyof({
  Km: null,
  Mile: null,
  Block: null
}, 'RentalRateDistanceUnit')

export interface RentalRateDistance {
  unlimited: boolean,
  unit: RentalRateDistanceUnit,
  amount: Option<number>,
  additional: Option<Money>
}

export const RentalRateDistance = t.type({
  unlimited: t.boolean,
  unit: RentalRateDistanceUnit,
  amount: optionFromNullable(t.Integer),
  additional: optionFromNullable(Money)
}, 'RentalRateDistance')

export type SpecialEquipment =
  | 'InfantChildSeat'
  | 'ChildToddlerSeat'
  | 'BoosterSeat'
  | 'NeverLostGPS'
  | 'SnowTyres'

export const SpecialEquipment = t.keyof({
  InfantChildSeat: null,
  ChildToddlerSeat: null,
  BoosterSeat: null,
  NeverLostGPS: null,
  SnowTyres: null
}, 'SpecialEquipment')

export interface PricedSpecialEquipment {
  id: SpecialEquipment,
  units: number,
  cost: Money,
  taxInclusive: boolean,
  includedInRate: boolean
}

export const PricedSpecialEquipment = t.type({
  id: SpecialEquipment,
  units: t.Integer,
  cost: Money,
  taxInclusive: t.boolean,
  includedInRate: t.boolean
}, 'PricedSpecialEquipment')

export interface RentalRate {
  externalId: string,
  total: RentalRateTotal,
  distance: RentalRateDistance,
  superCoverIncluded: boolean,
  dropOff: Option<Money>,
  specialEquipments: Array<PricedSpecialEquipment>
}

export const RentalRate = t.type({
  externalId: t.string,
  total: RentalRateTotal,
  distance: RentalRateDistance,
  superCoverIncluded: t.boolean,
  dropOff: optionFromNullable(Money),
  specialEquipments: t.array(PricedSpecialEquipment)
}, 'RentalRate')

export interface AvailableRentalRate {
  availableVehicleId: UUID,
  rentalRate: RentalRate
}

export const AvailableRentalRate = t.type({
  availableVehicleId: UUID,
  rentalRate: RentalRate
}, 'AvailableRentalRate')

export interface AvailableSpecialEquipment {
  id: SpecialEquipment,
  estimatedUnitCost: Money,
  atMost: number
}

export const AvailableSpecialEquipment = t.type({
  id: SpecialEquipment,
  estimatedUnitCost: Money,
  atMost: t.Integer
}, 'AvailableSpecialEquipment')

export type VehicleTransmission =
  | 'Automatic'
  | 'Manual'

export const VehicleTransmission = t.keyof({
  Automatic: null,
  Manual: null
}, 'VehicleTransmission')

export type VehicleFuel =
  | 'Unspecified'
  | 'Diesel'
  | 'Hybrid'
  | 'Electric'
  | 'LPGCompressedGas'
  | 'Hydrogen'
  | 'MultiFuel'
  | 'Petrol'
  | 'Ethanol'

export const VehicleFuel = t.keyof({
  Unspecified: null,
  Diesel: null,
  Hybrid: null,
  Electric: null,
  LPGCompressedGas: null,
  Hydrogen: null,
  MultiFuel: null,
  Petrol: null,
  Ethanol: null
}, 'VehicleFuel')

export type VehicleDrive =
  | 'AllWheel'
  | 'FourWheel'
  | 'Unspecified'

export const VehicleDrive = t.keyof({
  AllWheel: null,
  FourWheel: null,
  Unspecified: null
}, 'VehicleDrive')

export type VehicleCategory =
  | 'Car'
  | 'Van'
  | 'Suv'
  | 'Convertible'
  | 'Limousine'
  | 'Wagon'
  | 'Pickup'
  | 'Motorhome'
  | 'AllTerrain'
  | 'Recreational'
  | 'Sport'
  | 'Special'
  | 'PickupExtendedCab'
  | 'RegularCabPickup'
  | 'SpecialOffer'
  | 'Coupe'
  | 'Monospace'
  | 'TwoWheelVehicle'
  | 'Roadster'
  | 'Crossover'
  | 'CommercialVanOrTruck'

export const VehicleCategory = t.keyof({
  Car: null,
  Van: null,
  Suv: null,
  Convertible: null,
  Limousine: null,
  Wagon: null,
  Pickup: null,
  Motorhome: null,
  AllTerrain: null,
  Recreational: null,
  Sport: null,
  Special: null,
  PickupExtendedCab: null,
  RegularCabPickup: null,
  SpecialOffer: null,
  Coupe: null,
  Monospace: null,
  TwoWheelVehicle: null,
  Roadster: null,
  Crossover: null,
  CommercialVanOrTruck: null
}, 'VehicleCategory')

export type VehicleSize =
  | 'Mini'
  | 'Subcompact'
  | 'Economy'
  | 'Compact'
  | 'Midsize'
  | 'Intermediate'
  | 'Standard'
  | 'Fullsize'
  | 'Luxury'
  | 'Premium'
  | 'Special'
  | 'MiniElite'
  | 'EconomyElite'
  | 'CompactElite'
  | 'IntermediateElite'
  | 'StandardElite'
  | 'FullsizeElite'
  | 'PremiumElite'
  | 'LuxuryElite'
  | 'Oversize'

export const VehicleSize = t.keyof({
  Mini: null,
  Subcompact: null,
  Economy: null,
  Compact: null,
  Midsize: null,
  Intermediate: null,
  Standard: null,
  Fullsize: null,
  Luxury: null,
  Premium: null,
  Special: null,
  MiniElite: null,
  EconomyElite: null,
  CompactElite: null,
  IntermediateElite: null,
  StandardElite: null,
  FullsizeElite: null,
  PremiumElite: null,
  LuxuryElite: null,
  Oversize: null
}, 'VehicleSize')

export interface Vehicle {
  code: Option<string>,
  codeContext: Option<string>,
  airConditioning: boolean,
  seats: Option<number>,
  baggage: Option<number>,
  transmission: Option<VehicleTransmission>,
  fuel: Option<VehicleFuel>,
  drive: Option<VehicleDrive>,
  doors: Option<number>,
  category: VehicleCategory,
  size: VehicleSize,
  model: string,
  modelCode: string,
  pictureId: string,
  segment: Option<string>
}

export const Vehicle = t.type({
  code: optionFromNullable(t.string),
  codeContext: optionFromNullable(t.string),
  airConditioning: t.boolean,
  seats: optionFromNullable(t.Integer),
  baggage: optionFromNullable(t.Integer),
  transmission: optionFromNullable(VehicleTransmission),
  fuel: optionFromNullable(VehicleFuel),
  drive: optionFromNullable(VehicleDrive),
  doors: optionFromNullable(t.Integer),
  category: VehicleCategory,
  size: VehicleSize,
  model: t.string,
  modelCode: t.string,
  pictureId: t.string,
  segment: optionFromNullable(t.string)
}, 'Vehicle')

export interface AvailableVehicle {
  id: UUID,
  queryId: UUID,
  externalId: string,
  vehicle: Vehicle,
  fare: AvailableFare,
  rentalRate: RentalRate
}

export const AvailableVehicle = t.type({
  id: UUID,
  queryId: UUID,
  externalId: t.string,
  vehicle: Vehicle,
  fare: AvailableFare,
  rentalRate: RentalRate
}, 'AvailableVehicle')

export type ReservationProfile =
  | 'Leisure'
  | 'Business'
  | 'TourOperator'

export const ReservationProfile = t.keyof({
  Leisure: null,
  Business: null,
  TourOperator: null
}, 'ReservationProfile')

export interface AvailableVehicleSearchQuery {
  reservationProfile: ReservationProfile,
  pickUpLocation: string,
  pickUpLocalDate: LocalDate,
  pickUpLocalTime: LocalTime,
  dropOffLocation: string,
  dropOffLocalDate: LocalDate,
  dropOffLocalTime: LocalTime
}

export const AvailableVehicleSearchQuery = t.type({
  reservationProfile: ReservationProfile,
  pickUpLocation: t.string,
  pickUpLocalDate: LocalDate,
  pickUpLocalTime: LocalTime,
  dropOffLocation: t.string,
  dropOffLocalDate: LocalDate,
  dropOffLocalTime: LocalTime
}, 'AvailableVehicleSearchQuery')

export interface VehicleAvailability {
  vehicle: Vehicle,
  availableRentalRatesByFare: Record<UUID, AvailableRentalRate>
}

export const VehicleAvailability = t.type({
  vehicle: Vehicle,
  availableRentalRatesByFare: t.record(UUID, AvailableRentalRate)
}, 'VehicleAvailability')

export interface AvailableVehicleSearchResult {
  taxPercent: Option<number>,
  fares: Array<AvailableFare>,
  availability: Array<VehicleAvailability>
}

export const AvailableVehicleSearchResult = t.type({
  taxPercent: optionFromNullable(t.number),
  fares: t.array(AvailableFare),
  availability: t.array(VehicleAvailability)
}, 'AvailableVehicleSearchResult')

export type DayOfWeek =
  | 'Monday'
  | 'Tuesday'
  | 'Wednesday'
  | 'Thursday'
  | 'Friday'
  | 'Saturday'
  | 'Sunday'

export const DayOfWeek = t.keyof({
  Monday: null,
  Tuesday: null,
  Wednesday: null,
  Thursday: null,
  Friday: null,
  Saturday: null,
  Sunday: null
}, 'DayOfWeek')

export interface OpeningHours {
  open: string,
  close: string
}

export const OpeningHours = t.type({
  open: t.string,
  close: t.string
}, 'OpeningHours')

export interface Location {
  recordType: string,
  actionCode: string,
  recordNumber: string,
  vendorId: string,
  oagCode: string,
  country: string,
  state: string,
  zipCode: string,
  city: string,
  address1: string,
  address2: string,
  address3: string,
  phone: string,
  altPhone: string,
  fax: string,
  telex: string,
  webUrl: string,
  email: string,
  openingHours: {
    Monday?: Array<OpeningHours>,
    Tuesday?: Array<OpeningHours>,
    Wednesday?: Array<OpeningHours>,
    Thursday?: Array<OpeningHours>,
    Friday?: Array<OpeningHours>,
    Saturday?: Array<OpeningHours>,
    Sunday?: Array<OpeningHours>
  },
  latitude: string,
  longitude: string,
  description: string,
  locType1: string,
  locType2: string,
  truckOrVan: string,
  csi: string,
  csiDailyRate: string,
  csiWeeklyRate: string,
  cst: string,
  cstDailyRate: string,
  cstWeeklyRate: string,
  bst: string,
  bstDailyRate: string,
  bstWeeklyRate: string,
  nev: string,
  nevDailyRate: string,
  nevWeeklyRate: string,
  skv: string,
  skvDailyRate: string,
  skvWeeklyRate: string,
  sno: string,
  snoDailyRate: string,
  snoWeeklyRate: string,
  sbr: string,
  sbrDailyRate: string,
  sbrWeeklyRate: string,
  src: string,
  srcDailyRate: string,
  srcWeeklyRate: string,
  hmm: string,
  hmmDailyRate: string,
  hmmWeeklyRate: string,
  ldw: string,
  ldwDailyRate: string,
  ldwWeeklyRate: string,
  swd: string,
  swdDailyRate: string,
  swdWeeklyRate: string,
  lis: string,
  lisDailyRate: string,
  lisWeeklyRate: string,
  ppi: string,
  ppiDailyRate: string,
  ppiWeeklyRate: string,
  tp: string,
  tpDailyRate: string,
  tpWeeklyRate: string,
  pkg: string,
  pkgDailyRate: string,
  pkgWeeklyRate: string
}

export const Location = t.type({
  recordType: t.string,
  actionCode: t.string,
  recordNumber: t.string,
  vendorId: t.string,
  oagCode: t.string,
  country: t.string,
  state: t.string,
  zipCode: t.string,
  city: t.string,
  address1: t.string,
  address2: t.string,
  address3: t.string,
  phone: t.string,
  altPhone: t.string,
  fax: t.string,
  telex: t.string,
  webUrl: t.string,
  email: t.string,
  openingHours: t.partial({
    Monday: t.array(OpeningHours),
    Tuesday: t.array(OpeningHours),
    Wednesday: t.array(OpeningHours),
    Thursday: t.array(OpeningHours),
    Friday: t.array(OpeningHours),
    Saturday: t.array(OpeningHours),
    Sunday: t.array(OpeningHours)
  }),
  latitude: t.string,
  longitude: t.string,
  description: t.string,
  locType1: t.string,
  locType2: t.string,
  truckOrVan: t.string,
  csi: t.string,
  csiDailyRate: t.string,
  csiWeeklyRate: t.string,
  cst: t.string,
  cstDailyRate: t.string,
  cstWeeklyRate: t.string,
  bst: t.string,
  bstDailyRate: t.string,
  bstWeeklyRate: t.string,
  nev: t.string,
  nevDailyRate: t.string,
  nevWeeklyRate: t.string,
  skv: t.string,
  skvDailyRate: t.string,
  skvWeeklyRate: t.string,
  sno: t.string,
  snoDailyRate: t.string,
  snoWeeklyRate: t.string,
  sbr: t.string,
  sbrDailyRate: t.string,
  sbrWeeklyRate: t.string,
  src: t.string,
  srcDailyRate: t.string,
  srcWeeklyRate: t.string,
  hmm: t.string,
  hmmDailyRate: t.string,
  hmmWeeklyRate: t.string,
  ldw: t.string,
  ldwDailyRate: t.string,
  ldwWeeklyRate: t.string,
  swd: t.string,
  swdDailyRate: t.string,
  swdWeeklyRate: t.string,
  lis: t.string,
  lisDailyRate: t.string,
  lisWeeklyRate: t.string,
  ppi: t.string,
  ppiDailyRate: t.string,
  ppiWeeklyRate: t.string,
  tp: t.string,
  tpDailyRate: t.string,
  tpWeeklyRate: t.string,
  pkg: t.string,
  pkgDailyRate: t.string,
  pkgWeeklyRate: t.string
}, 'Location')

export interface LocationSearchResult {
  airports: Option<Array<Location>>,
  stations: Option<Array<Location>>,
  cities: Option<Array<Location>>,
  hotels: Option<Array<Location>>
}

export const LocationSearchResult = t.type({
  airports: optionFromNullable(t.array(Location)),
  stations: optionFromNullable(t.array(Location)),
  cities: optionFromNullable(t.array(Location)),
  hotels: optionFromNullable(t.array(Location))
}, 'LocationSearchResult')

export interface SelectedSpecialEquipment {
  id: SpecialEquipment,
  units: number
}

export const SelectedSpecialEquipment = t.type({
  id: SpecialEquipment,
  units: t.Integer
}, 'SelectedSpecialEquipment')
"
`;

exports[`getModels should return the models in the right (source4) 1`] = `
"// DO NOT EDIT MANUALLY - metarpheus-generated
import * as t from 'io-ts'
// @ts-ignore
import { optionFromNullable } from 'io-ts-types/lib/optionFromNullable'
// @ts-ignore
import { Option } from 'fp-ts/lib/Option'


interface Newtype<URI, A> {
  _URI: URI
  _A: A
}
interface Iso<S, A> {
  unwrap: (s: S) => A
  wrap: (a: A) => S
}
const unsafeCoerce = <A, B>(a: A): B => a as any
type Carrier<N extends Newtype<any, any>> = N['_A']
type AnyNewtype = Newtype<any, any>
const fromNewtype = <N extends AnyNewtype>() => <O>(type: t.Type<Carrier<N>, O>): t.Type<N, O> =>
  type as any
const iso = <S extends AnyNewtype>(): Iso<S, Carrier<S>> =>
  ({ wrap: unsafeCoerce, unwrap: unsafeCoerce })

export const VoidFromUnit = new t.Type<void, {}>(
  'VoidFromUnit',
  (_m): _m is void => true,
  () => t.success(undefined),
  () => ({})
)
export interface ActivationEnergy {
  temperature: number,
  value: number
}

export const ActivationEnergy = t.type({
  temperature: t.number,
  value: t.number
}, 'ActivationEnergy')

export interface Id<A> extends Newtype<{ readonly Id: unique symbol, readonly Id_A: A }, UUID> {}

export function Id<A>() { return fromNewtype<Id<A>>()(UUID) }
export function idIso<A>() { return iso<Id<A>>() }

export interface Layer {
  discretisationLayers: number,
  externalDiameter: number,
  initialTemperature: number,
  materialId: Id<Material>
}

export const Layer = t.type({
  discretisationLayers: t.Integer,
  externalDiameter: t.number,
  initialTemperature: t.number,
  materialId: Id<t.TypeOf<typeof Material>>()
}, 'Layer')

export interface ConductorLayer extends Newtype<{ readonly ConductorLayer: unique symbol }, Layer> {}

export const ConductorLayer = fromNewtype<ConductorLayer>()(Layer);
export const conductorLayerIso = iso<ConductorLayer>();

export interface InternalSemiconductiveLayer extends Newtype<{ readonly InternalSemiconductiveLayer: unique symbol }, Layer> {}

export const InternalSemiconductiveLayer = fromNewtype<InternalSemiconductiveLayer>()(Layer);
export const internalSemiconductiveLayerIso = iso<InternalSemiconductiveLayer>();

export interface InsulationLayer extends Newtype<{ readonly InsulationLayer: unique symbol }, Layer> {}

export const InsulationLayer = fromNewtype<InsulationLayer>()(Layer);
export const insulationLayerIso = iso<InsulationLayer>();

export interface ExternalSemiconductiveLayer extends Newtype<{ readonly ExternalSemiconductiveLayer: unique symbol }, Layer> {}

export const ExternalSemiconductiveLayer = fromNewtype<ExternalSemiconductiveLayer>()(Layer);
export const externalSemiconductiveLayerIso = iso<ExternalSemiconductiveLayer>();

export type ZoneType =
  | 'Air'
  | 'Steam'
  | 'Water'
  | 'WaterTrans'
  | 'Nitrogen'
  | 'NitrogenHeat'
  | 'NitrogenTrans'
  | 'NitrogenCool'
  | 'RhodorsilSiliconeOil'
  | 'DowcorSiliconeOil'
  | 'Flange'

export const ZoneType = t.keyof({
  Air: null,
  Steam: null,
  Water: null,
  WaterTrans: null,
  Nitrogen: null,
  NitrogenHeat: null,
  NitrogenTrans: null,
  NitrogenCool: null,
  RhodorsilSiliconeOil: null,
  DowcorSiliconeOil: null,
  Flange: null
}, 'ZoneType')

export interface Zone {
  type: ZoneType,
  temperature: number,
  linearlyVaryingTemperature: boolean,
  length: number,
  tubeDiameter: number,
  tubeAbsolutePressure: number,
  tubeEmissivity: number,
  cableEmissivity: number,
  turbulentWater: boolean,
  flowRate: number
}

export const Zone = t.type({
  type: ZoneType,
  temperature: t.number,
  linearlyVaryingTemperature: t.boolean,
  length: t.number,
  tubeDiameter: t.number,
  tubeAbsolutePressure: t.number,
  tubeEmissivity: t.number,
  cableEmissivity: t.number,
  turbulentWater: t.boolean,
  flowRate: t.number
}, 'Zone')

export interface CalculationInput {
  name: string,
  lineSpeedRangeStart: number,
  lineSpeedRangeEnd: number,
  lineSpeedRangeStep: number,
  longitudinalCalculationStep: number,
  longitudinalCalculationSavingSteps: number,
  longitudinalTouchPoint: number,
  longitudinalWaterLevel: number,
  cableRadialPositions: Array<Option<number>>,
  conductorTransversalSection: number,
  conductorLayer: ConductorLayer,
  internalSemiconductiveLayer: InternalSemiconductiveLayer,
  insulationLayer: InsulationLayer,
  externalSemiconductiveLayer: ExternalSemiconductiveLayer,
  zones: Array<Zone>
}

export const CalculationInput = t.type({
  name: t.string,
  lineSpeedRangeStart: t.number,
  lineSpeedRangeEnd: t.number,
  lineSpeedRangeStep: t.number,
  longitudinalCalculationStep: t.number,
  longitudinalCalculationSavingSteps: t.Integer,
  longitudinalTouchPoint: t.number,
  longitudinalWaterLevel: t.number,
  cableRadialPositions: t.array(optionFromNullable(t.number)),
  conductorTransversalSection: t.number,
  conductorLayer: ConductorLayer,
  internalSemiconductiveLayer: InternalSemiconductiveLayer,
  insulationLayer: InsulationLayer,
  externalSemiconductiveLayer: ExternalSemiconductiveLayer,
  zones: t.array(Zone)
}, 'CalculationInput')

export interface TemperaturePoint {
  linearPositionIndex: number,
  radialPositionIndex: number,
  temperature: number
}

export const TemperaturePoint = t.type({
  linearPositionIndex: t.Integer,
  radialPositionIndex: t.Integer,
  temperature: t.number
}, 'TemperaturePoint')

export interface CrossLinkingPoint {
  linearPositionIndex: number,
  radialPositionIndex: number,
  crossLinkingDegree: number
}

export const CrossLinkingPoint = t.type({
  linearPositionIndex: t.Integer,
  radialPositionIndex: t.Integer,
  crossLinkingDegree: t.number
}, 'CrossLinkingPoint')

export interface CalculationRun {
  conductorMaxTemperature: Celsius,
  conductorMaxLongitudinalPosition: Meters,
  cableSurfaceMaxTemperature: Celsius,
  cableSurfaceMaxLongitudinalPosition: Meters,
  conductorTouchpointTemperature: Celsius,
  conductorTouchpointLongitudinalPosition: Meters,
  cableSurfaceTouchpointTemperature: Celsius,
  conductorWaterLevelTemperature: Celsius,
  waterLevelLongitudinalPosition: Meters,
  cableSurfaceWaterLevelTemperature: Celsius,
  waterLevelMaxCableTemperature: Celsius,
  waterLevelMaximumRadialPosition: Millimiters,
  lineSpeed: MetersPerMinute,
  temperaturePoints: Array<TemperaturePoint>,
  crossLinkingPoints: Array<CrossLinkingPoint>
}

export const CalculationRun = t.type({
  conductorMaxTemperature: Celsius,
  conductorMaxLongitudinalPosition: Meters,
  cableSurfaceMaxTemperature: Celsius,
  cableSurfaceMaxLongitudinalPosition: Meters,
  conductorTouchpointTemperature: Celsius,
  conductorTouchpointLongitudinalPosition: Meters,
  cableSurfaceTouchpointTemperature: Celsius,
  conductorWaterLevelTemperature: Celsius,
  waterLevelLongitudinalPosition: Meters,
  cableSurfaceWaterLevelTemperature: Celsius,
  waterLevelMaxCableTemperature: Celsius,
  waterLevelMaximumRadialPosition: Millimiters,
  lineSpeed: MetersPerMinute,
  temperaturePoints: t.array(TemperaturePoint),
  crossLinkingPoints: t.array(CrossLinkingPoint)
}, 'CalculationRun')

export interface CalculationOutput {
  lineSpeeds: Array<MetersPerMinute>,
  runs: Array<CalculationRun>
}

export const CalculationOutput = t.type({
  lineSpeeds: t.array(MetersPerMinute),
  runs: t.array(CalculationRun)
}, 'CalculationOutput')

export interface CrossLinksFormationTime {
  temperature: number,
  value: number
}

export const CrossLinksFormationTime = t.type({
  temperature: t.number,
  value: t.number
}, 'CrossLinksFormationTime')

export interface Entity<A> {
  id: Id<A>,
  value: A
}

export const Entity = <A extends t.Mixed>(A: A) => t.type({
  id: Id<t.TypeOf<typeof A>>(),
  value: A
}, 'Entity')

export interface ExternalId<A> extends Newtype<{ readonly ExternalId: unique symbol, readonly ExternalId_A: A }, string> {}

export function ExternalId<A>() { return fromNewtype<ExternalId<A>>()(t.string) }
export function externalIdIso<A>() { return iso<ExternalId<A>>() }

export interface VolumetricSpecificHeat {
  temperature: number,
  value: number
}

export const VolumetricSpecificHeat = t.type({
  temperature: t.number,
  value: t.number
}, 'VolumetricSpecificHeat')

export interface ThermalResistivity {
  temperature: number,
  value: number
}

export const ThermalResistivity = t.type({
  temperature: t.number,
  value: t.number
}, 'ThermalResistivity')

export interface Material {
  volumetricSpecificHeatMap: Array<VolumetricSpecificHeat>,
  thermalResistivityMap: Array<ThermalResistivity>,
  crossLinksFormationTimeMap: Array<CrossLinksFormationTime>,
  activationEnergyMap: Array<ActivationEnergy>
}

export const Material = t.type({
  volumetricSpecificHeatMap: t.array(VolumetricSpecificHeat),
  thermalResistivityMap: t.array(ThermalResistivity),
  crossLinksFormationTimeMap: t.array(CrossLinksFormationTime),
  activationEnergyMap: t.array(ActivationEnergy)
}, 'Material')

export type Role =
  | 'Admin'
  | 'User'

export const Role = t.keyof({
  Admin: null,
  User: null
}, 'Role')

export interface User {
  externalId: ExternalId<User>,
  role: Role,
  fullName: Option<string>
}

export const User = t.type({
  externalId: ExternalId<t.TypeOf<typeof User>>(),
  role: Role,
  fullName: optionFromNullable(t.string)
}, 'User')
"
`;

exports[`getRoutes should return the routes in the right (source3) 1`] = `
"// DO NOT EDIT MANUALLY - metarpheus-generated
import axios from 'axios'
import * as E from 'fp-ts/lib/Either'
import * as TE from 'fp-ts/lib/TaskEither'
import * as t from 'io-ts'
// @ts-ignore
import { optionFromNullable } from 'io-ts-types/lib/optionFromNullable'
// @ts-ignore
import { Option } from 'fp-ts/lib/Option'
import * as m from './model-ts'
import { pipe } from 'fp-ts/lib/pipeable'
import { flow } from 'fp-ts/lib/function'

export interface RouteConfig {
  apiEndpoint: string,
  timeout: number
}

export default function getRoutes(_metarpheusRouteConfig: RouteConfig) {
  return {
    /** Create a new search query for available vehicles */
    availableVehicleController_createQuery: function ({ query }: { query: m.AvailableVehicleSearchQuery }): TE.TaskEither<unknown, m.UUID> {
      return pipe(
        TE.tryCatch(() => axios({
          method: 'post',
          url: \`\${_metarpheusRouteConfig.apiEndpoint}/availableVehicles/createQuery\`,
          params: {

          },
          data: {
          query: m.AvailableVehicleSearchQuery.encode(query)
          },
          headers: {
          'Content-Type': 'application/json'
          },
          timeout: _metarpheusRouteConfig.timeout
        }), (v): unknown => v),
        TE.map(res => res.data),
        TE.chainEitherK(flow(m.UUID.decode, E.mapLeft((e): unknown => e)))
      )
    },

    /** Returns an existing query for available vehicles */
    availableVehicleController_readQuery: function ({ id }: { id: m.UUID }): TE.TaskEither<unknown, m.AvailableVehicleSearchQuery> {
      return pipe(
        TE.tryCatch(() => axios({
          method: 'get',
          url: \`\${_metarpheusRouteConfig.apiEndpoint}/availableVehicles/readQuery\`,
          params: {
            id: m.UUID.encode(id)
          },
          data: {

          },
          headers: {
          'Content-Type': 'application/json',
          'Pragma': 'no-cache',
          'Cache-Control': 'no-cache, no-store'
          },
          timeout: _metarpheusRouteConfig.timeout
        }), (v): unknown => v),
        TE.map(res => res.data),
        TE.chainEitherK(flow(m.AvailableVehicleSearchQuery.decode, E.mapLeft((e): unknown => e)))
      )
    },

    /** Returns the resulting available vehicles for the created query */
    availableVehicleController_readResult: function ({ id }: { id: m.UUID }): TE.TaskEither<unknown, m.AvailableVehicleSearchResult> {
      return pipe(
        TE.tryCatch(() => axios({
          method: 'get',
          url: \`\${_metarpheusRouteConfig.apiEndpoint}/availableVehicles/readResult\`,
          params: {
            id: m.UUID.encode(id)
          },
          data: {

          },
          headers: {
          'Content-Type': 'application/json',
          'Pragma': 'no-cache',
          'Cache-Control': 'no-cache, no-store'
          },
          timeout: _metarpheusRouteConfig.timeout
        }), (v): unknown => v),
        TE.map(res => res.data),
        TE.chainEitherK(flow(m.AvailableVehicleSearchResult.decode, E.mapLeft((e): unknown => e)))
      )
    },

    /** Updates the selected SpecialEquipments for the specified AvailableVehicle */
    availableVehicleController_updateSpecialEquipments: function ({ token, availableVehicleId, specialEquipments }: { token: string, availableVehicleId: m.UUID, specialEquipments: Array<m.SelectedSpecialEquipment> }): TE.TaskEither<unknown, m.UUID> {
      return pipe(
        TE.tryCatch(() => axios({
          method: 'post',
          url: \`\${_metarpheusRouteConfig.apiEndpoint}/availableVehicles/updateSpecialEquipments\`,
          params: {

          },
          data: {
          availableVehicleId: m.UUID.encode(availableVehicleId),
          specialEquipments: t.array(m.SelectedSpecialEquipment).encode(specialEquipments)
          },
          headers: {
          'Content-Type': 'application/json',
          'Authorization': \`Token token=\\"\${token}\\"\`
          },
          timeout: _metarpheusRouteConfig.timeout
        }), (v): unknown => v),
        TE.map(res => res.data),
        TE.chainEitherK(flow(m.UUID.decode, E.mapLeft((e): unknown => e)))
      )
    },

    /** Returns the specified available vehicle */
    availableVehicleController_read: function ({ id }: { id: m.UUID }): TE.TaskEither<unknown, m.AvailableVehicle> {
      return pipe(
        TE.tryCatch(() => axios({
          method: 'get',
          url: \`\${_metarpheusRouteConfig.apiEndpoint}/availableVehicles/read\`,
          params: {
            id: m.UUID.encode(id)
          },
          data: {

          },
          headers: {
          'Content-Type': 'application/json',
          'Pragma': 'no-cache',
          'Cache-Control': 'no-cache, no-store'
          },
          timeout: _metarpheusRouteConfig.timeout
        }), (v): unknown => v),
        TE.map(res => res.data),
        TE.chainEitherK(flow(m.AvailableVehicle.decode, E.mapLeft((e): unknown => e)))
      )
    },

    /** Search locations */
    locationsController_search: function ({ query }: { query: string }): TE.TaskEither<unknown, m.LocationSearchResult> {
      return pipe(
        TE.tryCatch(() => axios({
          method: 'get',
          url: \`\${_metarpheusRouteConfig.apiEndpoint}/locations/search\`,
          params: {
            query: t.string.encode(query)
          },
          data: {

          },
          headers: {
          'Content-Type': 'application/json',
          'Pragma': 'no-cache',
          'Cache-Control': 'no-cache, no-store'
          },
          timeout: _metarpheusRouteConfig.timeout
        }), (v): unknown => v),
        TE.map(res => res.data),
        TE.chainEitherK(flow(m.LocationSearchResult.decode, E.mapLeft((e): unknown => e)))
      )
    },

    /** Get available SpecialEquipment for a given pickUp Location and rental duration */
    locationsController_searchSpecialEquipments: function ({ location, duration, param1, param2 }: { location: string, duration: number, param1: number, param2: string }): TE.TaskEither<unknown, Array<m.AvailableSpecialEquipment>> {
      return pipe(
        TE.tryCatch(() => axios({
          method: 'get',
          url: \`\${_metarpheusRouteConfig.apiEndpoint}/locations/searchSpecialEquipments/\${param1}/foo/\${param2}\`,
          params: {
            location: t.string.encode(location),
            duration: t.Integer.encode(duration)
          },
          data: {

          },
          headers: {
          'Content-Type': 'application/json',
          'Pragma': 'no-cache',
          'Cache-Control': 'no-cache, no-store'
          },
          timeout: _metarpheusRouteConfig.timeout
        }), (v): unknown => v),
        TE.map(res => res.data),
        TE.chainEitherK(flow(t.array(m.AvailableSpecialEquipment).decode, E.mapLeft((e): unknown => e)))
      )
    },

    /** log a user in */
    userController_login: function ({ data }: { data: m.API_UserLoginCredentials }): TE.TaskEither<unknown, m.API_UserAuthCredentials> {
      return pipe(
        TE.tryCatch(() => axios({
          method: 'post',
          url: \`\${_metarpheusRouteConfig.apiEndpoint}/users/login\`,
          params: {

          },
          data: m.API_UserLoginCredentials.encode(data),
          headers: {
          'Content-Type': 'application/json'
          },
          timeout: _metarpheusRouteConfig.timeout
        }), (v): unknown => v),
        TE.map(res => res.data),
        TE.chainEitherK(flow(m.API_UserAuthCredentials.decode, E.mapLeft((e): unknown => e)))
      )
    }
  }
}
"
`;

exports[`getRoutes should return the routes in the right (source4) 1`] = `
"// DO NOT EDIT MANUALLY - metarpheus-generated
import axios from 'axios'
import * as E from 'fp-ts/lib/Either'
import * as TE from 'fp-ts/lib/TaskEither'
import * as t from 'io-ts'
// @ts-ignore
import { optionFromNullable } from 'io-ts-types/lib/optionFromNullable'
// @ts-ignore
import { Option } from 'fp-ts/lib/Option'
import * as m from './model-ts'
import { pipe } from 'fp-ts/lib/pipeable'
import { flow } from 'fp-ts/lib/function'

export interface RouteConfig {
  apiEndpoint: string,
  timeout: number
}

export default function getRoutes(_metarpheusRouteConfig: RouteConfig) {
  return {
    materialController_readAll: function ({  }: {  }): TE.TaskEither<unknown, Array<m.Entity<m.Material>>> {
      return pipe(
        TE.tryCatch(() => axios({
          method: 'get',
          url: \`\${_metarpheusRouteConfig.apiEndpoint}/material/readAll\`,
          params: {

          },
          data: {

          },
          headers: {
          'Content-Type': 'application/json',
          'Pragma': 'no-cache',
          'Cache-Control': 'no-cache, no-store'
          },
          timeout: _metarpheusRouteConfig.timeout
        }), (v): unknown => v),
        TE.map(res => res.data),
        TE.chainEitherK(flow(t.array(m.Entity(m.Material)).decode, E.mapLeft((e): unknown => e)))
      )
    },

    calculationController_run: function ({ calculation }: { calculation: m.CalculationInput }): TE.TaskEither<unknown, m.CalculationOutput> {
      return pipe(
        TE.tryCatch(() => axios({
          method: 'post',
          url: \`\${_metarpheusRouteConfig.apiEndpoint}/calculation/run\`,
          params: {

          },
          data: {
          calculation: m.CalculationInput.encode(calculation)
          },
          headers: {
          'Content-Type': 'application/json'
          },
          timeout: _metarpheusRouteConfig.timeout
        }), (v): unknown => v),
        TE.map(res => res.data),
        TE.chainEitherK(flow(m.CalculationOutput.decode, E.mapLeft((e): unknown => e)))
      )
    },

    meController_read: function ({  }: {  }): TE.TaskEither<unknown, m.Entity<m.User>> {
      return pipe(
        TE.tryCatch(() => axios({
          method: 'get',
          url: \`\${_metarpheusRouteConfig.apiEndpoint}/me/read\`,
          params: {

          },
          data: {

          },
          headers: {
          'Content-Type': 'application/json',
          'Pragma': 'no-cache',
          'Cache-Control': 'no-cache, no-store'
          },
          timeout: _metarpheusRouteConfig.timeout
        }), (v): unknown => v),
        TE.map(res => res.data),
        TE.chainEitherK(flow(m.Entity(m.User).decode, E.mapLeft((e): unknown => e)))
      )
    },

    userController_readAll: function ({  }: {  }): TE.TaskEither<unknown, Array<m.Entity<m.User>>> {
      return pipe(
        TE.tryCatch(() => axios({
          method: 'get',
          url: \`\${_metarpheusRouteConfig.apiEndpoint}/user/readAll\`,
          params: {

          },
          data: {

          },
          headers: {
          'Content-Type': 'application/json',
          'Pragma': 'no-cache',
          'Cache-Control': 'no-cache, no-store'
          },
          timeout: _metarpheusRouteConfig.timeout
        }), (v): unknown => v),
        TE.map(res => res.data),
        TE.chainEitherK(flow(t.array(m.Entity(m.User)).decode, E.mapLeft((e): unknown => e)))
      )
    },

    userController_read: function ({ id }: { id: m.Id<m.User> }): TE.TaskEither<unknown, Option<m.Entity<m.User>>> {
      return pipe(
        TE.tryCatch(() => axios({
          method: 'get',
          url: \`\${_metarpheusRouteConfig.apiEndpoint}/user/read\`,
          params: {
            id: m.Id<t.TypeOf<typeof m.User>>().encode(id)
          },
          data: {

          },
          headers: {
          'Content-Type': 'application/json',
          'Pragma': 'no-cache',
          'Cache-Control': 'no-cache, no-store'
          },
          timeout: _metarpheusRouteConfig.timeout
        }), (v): unknown => v),
        TE.map(res => res.data),
        TE.chainEitherK(flow(optionFromNullable(m.Entity(m.User)).decode, E.mapLeft((e): unknown => e)))
      )
    },

    userController_create: function ({ user }: { user:
  | m.User
  | undefined }): TE.TaskEither<unknown, m.Id<m.User>> {
      return pipe(
        TE.tryCatch(() => axios({
          method: 'post',
          url: \`\${_metarpheusRouteConfig.apiEndpoint}/user/create\`,
          params: {

          },
          data: {
          user: t.union([
  m.User,
  t.undefined
]).encode(user)
          },
          headers: {
          'Content-Type': 'application/json'
          },
          timeout: _metarpheusRouteConfig.timeout
        }), (v): unknown => v),
        TE.map(res => res.data),
        TE.chainEitherK(flow(m.Id<t.TypeOf<typeof m.User>>().decode, E.mapLeft((e): unknown => e)))
      )
    },

    userController_update: function ({ user }: { user: m.Entity<m.User> }): TE.TaskEither<unknown, void> {
      return pipe(
        TE.tryCatch(() => axios({
          method: 'post',
          url: \`\${_metarpheusRouteConfig.apiEndpoint}/user/update\`,
          params: {

          },
          data: {
          user: m.Entity(m.User).encode(user)
          },
          headers: {
          'Content-Type': 'application/json'
          },
          timeout: _metarpheusRouteConfig.timeout
        }), (v): unknown => v),
        TE.map(res => res.data),
        TE.chainEitherK(flow(m.VoidFromUnit.decode, E.mapLeft((e): unknown => e)))
      )
    },

    userController_delete: function ({ id }: { id: m.Id<m.User> }): TE.TaskEither<unknown, void> {
      return pipe(
        TE.tryCatch(() => axios({
          method: 'post',
          url: \`\${_metarpheusRouteConfig.apiEndpoint}/user/delete\`,
          params: {

          },
          data: {
          id: m.Id<t.TypeOf<typeof m.User>>().encode(id)
          },
          headers: {
          'Content-Type': 'application/json'
          },
          timeout: _metarpheusRouteConfig.timeout
        }), (v): unknown => v),
        TE.map(res => res.data),
        TE.chainEitherK(flow(m.VoidFromUnit.decode, E.mapLeft((e): unknown => e)))
      )
    }
  }
}
"
`;
