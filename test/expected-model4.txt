// DO NOT EDIT MANUALLY - metarpheus-generated
import * as t from 'io-ts'


interface Newtype<URI, A> {
  _URI: URI
  _A: A
}
interface Iso<S, A> {
  unwrap: (s: S) => A
  wrap: (a: A) => S
}
const unsafeCoerce = <A, B>(a: A): B => a as any
type Carrier<N extends Newtype<any, any>> = N['_A']
type AnyNewtype = Newtype<any, any>
const fromNewtype = <N extends AnyNewtype>() => <O>(type: t.Type<Carrier<N>, O>): t.Type<N, O> =>
  type as any
const iso = <S extends AnyNewtype>(): Iso<S, Carrier<S>> =>
  ({ wrap: unsafeCoerce, unwrap: unsafeCoerce })

export interface ActivationEnergy {
  temperature: number,
  value: number
}

export const ActivationEnergy = t.interface({
  temperature: t.number,
  value: t.number
}, 'ActivationEnergy')

export interface Layer {
  discretisationLayers: number,
  externalDiameter: number,
  initialTemperature: number,
  materialId: Id<Material>
}

export const Layer = t.interface({
  discretisationLayers: t.number,
  externalDiameter: t.number,
  initialTemperature: t.number,
  materialId: Id<Material>()
}, 'Layer')

export interface ConductorLayer extends Newtype<{ readonly ConductorLayer: unique symbol }, Layer> {}

export const ConductorLayer = fromNewtype<ConductorLayer>()(Layer);
export const conductorLayerIso = iso<ConductorLayer>();

export interface InternalSemiconductiveLayer extends Newtype<{ readonly InternalSemiconductiveLayer: unique symbol }, Layer> {}

export const InternalSemiconductiveLayer = fromNewtype<InternalSemiconductiveLayer>()(Layer);
export const internalSemiconductiveLayerIso = iso<InternalSemiconductiveLayer>();

export interface InsulationLayer extends Newtype<{ readonly InsulationLayer: unique symbol }, Layer> {}

export const InsulationLayer = fromNewtype<InsulationLayer>()(Layer);
export const insulationLayerIso = iso<InsulationLayer>();

export interface ExternalSemiconductiveLayer extends Newtype<{ readonly ExternalSemiconductiveLayer: unique symbol }, Layer> {}

export const ExternalSemiconductiveLayer = fromNewtype<ExternalSemiconductiveLayer>()(Layer);
export const externalSemiconductiveLayerIso = iso<ExternalSemiconductiveLayer>();

export type ZoneType =
  | 'Air'
  | 'Steam'
  | 'Water'
  | 'WaterTrans'
  | 'Nitrogen'
  | 'NitrogenHeat'
  | 'NitrogenTrans'
  | 'NitrogenCool'
  | 'RhodorsilSiliconeOil'
  | 'DowcorSiliconeOil'
  | 'Flange'

export const ZoneType = t.keyof({
  Air: true,
  Steam: true,
  Water: true,
  WaterTrans: true,
  Nitrogen: true,
  NitrogenHeat: true,
  NitrogenTrans: true,
  NitrogenCool: true,
  RhodorsilSiliconeOil: true,
  DowcorSiliconeOil: true,
  Flange: true
}, 'ZoneType')

export interface Zone {
  type: ZoneType,
  temperature: number,
  linearlyVaryingTemperature: boolean,
  length: number,
  tubeDiameter: number,
  tubeAbsolutePressure: number,
  tubeEmissivity: number,
  cableEmissivity: number,
  turbulentWater: boolean,
  flowRate: number
}

export const Zone = t.interface({
  type: ZoneType,
  temperature: t.number,
  linearlyVaryingTemperature: t.boolean,
  length: t.number,
  tubeDiameter: t.number,
  tubeAbsolutePressure: t.number,
  tubeEmissivity: t.number,
  cableEmissivity: t.number,
  turbulentWater: t.boolean,
  flowRate: t.number
}, 'Zone')

export interface CalculationInput {
  name: string,
  lineSpeedRangeStart: number,
  lineSpeedRangeEnd: number,
  lineSpeedRangeStep: number,
  longitudinalCalculationStep: number,
  longitudinalCalculationSavingSteps: number,
  longitudinalTouchPoint: number,
  longitudinalWaterLevel: number,
  cableRadialPositions: Array<
    | number
    | undefined>,
  conductorTransversalSection: number,
  conductorLayer: ConductorLayer,
  internalSemiconductiveLayer: InternalSemiconductiveLayer,
  insulationLayer: InsulationLayer,
  externalSemiconductiveLayer: ExternalSemiconductiveLayer,
  zones: Array<Zone>
}

export const CalculationInput = t.interface({
  name: t.string,
  lineSpeedRangeStart: t.number,
  lineSpeedRangeEnd: t.number,
  lineSpeedRangeStep: t.number,
  longitudinalCalculationStep: t.number,
  longitudinalCalculationSavingSteps: t.number,
  longitudinalTouchPoint: t.number,
  longitudinalWaterLevel: t.number,
  cableRadialPositions: t.array(t.union([
    t.number,
    t.undefined
  ])),
  conductorTransversalSection: t.number,
  conductorLayer: ConductorLayer,
  internalSemiconductiveLayer: InternalSemiconductiveLayer,
  insulationLayer: InsulationLayer,
  externalSemiconductiveLayer: ExternalSemiconductiveLayer,
  zones: t.array(Zone)
}, 'CalculationInput')

export interface TemperaturePoint {
  linearPositionIndex: number,
  radialPositionIndex: number,
  temperature: number
}

export const TemperaturePoint = t.interface({
  linearPositionIndex: t.number,
  radialPositionIndex: t.number,
  temperature: t.number
}, 'TemperaturePoint')

export interface CrossLinkingPoint {
  linearPositionIndex: number,
  radialPositionIndex: number,
  crossLinkingDegree: number
}

export const CrossLinkingPoint = t.interface({
  linearPositionIndex: t.number,
  radialPositionIndex: t.number,
  crossLinkingDegree: t.number
}, 'CrossLinkingPoint')

export interface CalculationRun {
  conductorMaxTemperature: Celsius,
  conductorMaxLongitudinalPosition: Meters,
  cableSurfaceMaxTemperature: Celsius,
  cableSurfaceMaxLongitudinalPosition: Meters,
  conductorTouchpointTemperature: Celsius,
  conductorTouchpointLongitudinalPosition: Meters,
  cableSurfaceTouchpointTemperature: Celsius,
  conductorWaterLevelTemperature: Celsius,
  waterLevelLongitudinalPosition: Meters,
  cableSurfaceWaterLevelTemperature: Celsius,
  waterLevelMaxCableTemperature: Celsius,
  waterLevelMaximumRadialPosition: Millimiters,
  lineSpeed: MetersPerMinute,
  temperaturePoints: Array<TemperaturePoint>,
  crossLinkingPoints: Array<CrossLinkingPoint>
}

export const CalculationRun = t.interface({
  conductorMaxTemperature: Celsius,
  conductorMaxLongitudinalPosition: Meters,
  cableSurfaceMaxTemperature: Celsius,
  cableSurfaceMaxLongitudinalPosition: Meters,
  conductorTouchpointTemperature: Celsius,
  conductorTouchpointLongitudinalPosition: Meters,
  cableSurfaceTouchpointTemperature: Celsius,
  conductorWaterLevelTemperature: Celsius,
  waterLevelLongitudinalPosition: Meters,
  cableSurfaceWaterLevelTemperature: Celsius,
  waterLevelMaxCableTemperature: Celsius,
  waterLevelMaximumRadialPosition: Millimiters,
  lineSpeed: MetersPerMinute,
  temperaturePoints: t.array(TemperaturePoint),
  crossLinkingPoints: t.array(CrossLinkingPoint)
}, 'CalculationRun')

export interface CalculationOutput {
  lineSpeeds: Array<MetersPerMinute>,
  runs: Array<CalculationRun>
}

export const CalculationOutput = t.interface({
  lineSpeeds: t.array(MetersPerMinute),
  runs: t.array(CalculationRun)
}, 'CalculationOutput')

export interface CrossLinksFormationTime {
  temperature: number,
  value: number
}

export const CrossLinksFormationTime = t.interface({
  temperature: t.number,
  value: t.number
}, 'CrossLinksFormationTime')

export interface Entity<A> {
  id: Id<A>,
  value: A
}

export const Entity = <A extends t.Any>(A: A) => t.interface({
  id: Id<A>(),
  value: A
}, 'Entity')

export interface ExternalId<A> extends Newtype<{ readonly ExternalId: unique symbol, readonly ExternalId_A: A }, string> {}

export function ExternalId<A>() { return fromNewtype<ExternalId<A>>()(t.string) }
export function externalIdIso<A>() { return iso<ExternalId<A>>() }

export interface Id<A> extends Newtype<{ readonly Id: unique symbol, readonly Id_A: A }, UUID> {}

export function Id<A>() { return fromNewtype<Id<A>>()(UUID) }
export function idIso<A>() { return iso<Id<A>>() }

export interface VolumetricSpecificHeat {
  temperature: number,
  value: number
}

export const VolumetricSpecificHeat = t.interface({
  temperature: t.number,
  value: t.number
}, 'VolumetricSpecificHeat')

export interface ThermalResistivity {
  temperature: number,
  value: number
}

export const ThermalResistivity = t.interface({
  temperature: t.number,
  value: t.number
}, 'ThermalResistivity')

export interface Material {
  volumetricSpecificHeatMap: Array<VolumetricSpecificHeat>,
  thermalResistivityMap: Array<ThermalResistivity>,
  crossLinksFormationTimeMap: Array<CrossLinksFormationTime>,
  activationEnergyMap: Array<ActivationEnergy>
}

export const Material = t.interface({
  volumetricSpecificHeatMap: t.array(VolumetricSpecificHeat),
  thermalResistivityMap: t.array(ThermalResistivity),
  crossLinksFormationTimeMap: t.array(CrossLinksFormationTime),
  activationEnergyMap: t.array(ActivationEnergy)
}, 'Material')

export type Role =
  | 'Admin'
  | 'User'

export const Role = t.keyof({
  Admin: true,
  User: true
}, 'Role')

export interface User {
  externalId: ExternalId<User>,
  role: Role,
  fullName?: string
}

export const User = t.interface({
  externalId: ExternalId<User>(),
  role: Role,
  fullName: t.union([
    t.string,
    t.undefined
  ])
}, 'User')
